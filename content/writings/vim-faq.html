---
title: Vim FAQ
---
<p>This is a bit of an addendum to my original <a href="/csc201-laboratory-vim" class="linodef linodef_node linodef_node_57" title="Node 57: CSC201 Laboratory: ViM">introduction</a> to Vim and a glimpse into some of its more advanced features. This also serves as a reference for anyone interested in a lightning talk I gave at the July 2010 <a  target='_blank' href="http://cdmug.org/">CDMUG</a>. I tried to spend that entire presentation wowing the crowd rather than teaching them how the Vimpossible can be accomplished.</p>
<ul>
<li><a href="#movement">How do you move around so fast?</a></li>
<li><a href="#viewports">Can I open multiple files at once?</a></li>
<li><a href="#coding">What about syntax highlighting and indentation?</a></li>
<li><a href="#folding">How do I get and use code folding?</a></li>
<li><a href="#completion">How do I enable/use code completion?</a></li>
<li><a href="#tags">And how do I jump to the function code definition?</a></li>
<li><a href="#lint">How can I check for syntax errors within my code?</a></li>
<li><a href="#filetype">My .module and .inc files don't appear as PHP?</a></li>
<li><a href="#external">How do I use external commands as input or filters?</a></li>
<li><a href="#shell">What do I need to run a shell within vim?</a></li>
<li><a href="#nerdtree">Is there some sort of file browser?</a></li>
</ul>
<h2 id="movement">How do you move around so fast?</h2>
<p>Movement commands are the key to working efficiently, so much so that most of the operations within Vim take movement parameters to know which text to operate over. First and foremost, use the <span class="geshifilter"><code class="text geshifilter-text">h</code></span>,<span class="geshifilter"><code class="text geshifilter-text">j</code></span>,<span class="geshifilter"><code class="text geshifilter-text">k</code></span>, and <span class="geshifilter"><code class="text geshifilter-text">l</code></span> (or arrow keys) to move a single space in each direction. The <span class="geshifilter"><code class="text geshifilter-text">w</code></span> key allows you to move forward a "word" and <span class="geshifilter"><code class="text geshifilter-text">b</code></span> moves backwards one word. You can even use <span class="geshifilter"><code class="text geshifilter-text">(</code></span> and <span class="geshifilter"><code class="text geshifilter-text">)</code></span> to move forwards/backwards a sentence and <span class="geshifilter"><code class="text geshifilter-text">{</code></span> and <span class="geshifilter"><code class="text geshifilter-text">}</code></span> to move by paragraph. These may be useful if you plan to write a lot, but developers will be more interested by <span class="geshifilter"><code class="text geshifilter-text">%</code></span>, which moves to the "matching" character/sequence. This would move to the matching closing brace, for example, or (with the <a  target='_blank' href="http://www.vim.org/scripts/script.php?script_id=39">matchit plugin</a>) the matching HTML tag. <span class="geshifilter"><code class="text geshifilter-text">*</code></span> searches for the word under the cursor, moving to the next match. <span class="geshifilter"><code class="text geshifilter-text">n</code></span> moves forward to the next match for the last search term while <span class="geshifilter"><code class="text geshifilter-text">N</code></span> searches backwards. </p>
<p>Each of these movement commands can be tied with a number (<em>x</em>) to mean "move distance <em>x</em> times." You may want to move three words forward, for example, or find the fourth instance of your search text. This becomes very useful for operations such as <span class="geshifilter"><code class="text geshifilter-text">d</code></span> (delete) or <span class="geshifilter"><code class="text geshifilter-text">c</code></span> (change), which accept movement parameters. This allows you to quickly delete the next sentence or change the preceding two words. Two of the most commonly needed parameters (to delete/change a whole line or to delete/change all of the line following the current position) can be performed with either <span class="geshifilter"><code class="text geshifilter-text">cc</code></span>/<span class="geshifilter"><code class="text geshifilter-text">dd</code></span> to affect the whole line or <span class="geshifilter"><code class="text geshifilter-text">C</code></span>/<span class="geshifilter"><code class="text geshifilter-text">D</code></span> to affect everything following the current position. <span class="geshifilter"><code class="text geshifilter-text">$</code></span> or <span class="geshifilter"><code class="text geshifilter-text">End</code></span> will take you to the end of the line so that <span class="geshifilter"><code class="text geshifilter-text">C</code></span> is equivalent to <span class="geshifilter"><code class="text geshifilter-text">c$</code></span> ; <span class="geshifilter"><code class="text geshifilter-text">&nbsp;</code></span> or <span class="geshifilter"><code class="text geshifilter-text">Home</code></span> will take you to the beginning.</p>
<p>You can also jump around your document via line numbers and other markers. Simply type <span class="geshifilter"><code class="text geshifilter-text">40G</code></span> to jump to the 40ths line. <span class="geshifilter"><code class="text geshifilter-text">gg</code></span> will take you to the first line (as will <span class="geshifilter"><code class="text geshifilter-text">1G</code></span> and <span class="geshifilter"><code class="text geshifilter-text">0G</code></span>) and <span class="geshifilter"><code class="text geshifilter-text">G</code></span> will take you to the final line in the document. You can mark a particular line so that you return to it later by using the <span class="geshifilter"><code class="text geshifilter-text">m</code></span> key. Each mark has a single-character name such as "f" so that you can mark the line which contains a particular <em>f</em>unction via <span class="geshifilter"><code class="text geshifilter-text">mf</code></span>. Later, you can recall (move the cursor to) that function via <span class="geshifilter"><code class="text geshifilter-text">'f</code></span>. Does that answer your question? :)</p>
<h2 id="viewports">Can I open multiple files at once?</h2>
<p>There are many different ways to edit or view multiple files with Vim. The simplest is to simply pass each file as a parameter when opening vim: <span class="geshifilter"><code class="text geshifilter-text">$ vim file1.php file2.php</code></span> or <span class="geshifilter"><code class="text geshifilter-text">$ vim file*.php</code></span>. You will now see the first file, but can switch to the next with <span class="geshifilter"><code class="text geshifilter-text">:n</code></span> or <span class="geshifilter"><code class="text geshifilter-text">:next</code></span>; switching back to the first is as simple as <span class="geshifilter"><code class="text geshifilter-text">:prev</code></span>. Combining this with the write command (i.e. saving), you can quickly modify a sequence of files via <span class="geshifilter"><code class="text geshifilter-text">:wn</code></span> commands.</p>
<p>You can also open two files in the same window by using <span class="geshifilter"><code class="text geshifilter-text">:split</code></span>, which will open the current file in a second viewport above the current. You can move between the two views of the same file by using the mouse (be sure to <span class="geshifilter"><code class="text geshifilter-text">:set mouse=a</code></span> in your .vimrc) or by pressing <span class="geshifilter"><code class="text geshifilter-text">&lt;C-w&gt;&lt;C-w&gt;</code></span> (control + 'w' twice). <span class="geshifilter"><code class="text geshifilter-text">:split somefile.txt</code></span> will create a new viewport viewing somefile.txt and <span class="geshifilter"><code class="text geshifilter-text">:new</code></span> will split into an empty file. You can add a 'v' in-front of the commands (<span class="geshifilter"><code class="text geshifilter-text">:vsplit</code></span> and <span class="geshifilter"><code class="text geshifilter-text">:vnew</code></span>) to create a vertical split instead. You can even create splits within splits and then adjust the divisions with the mouse, creating a completely custom division of your work space. Though I have yet to find a good use for this, you can impress your friends by rotating the windows around by using <span class="geshifilter"><code class="text geshifilter-text">&lt;C-w&gt;r</code></span>. </p>
<p>One of the newest features to Vim is tabs, which allow you to have multiple groupings of windows open. This would be as if firefox allowed you to open multiple pages within a single window <em>as well</em> as opening multiple tabs. To create a new tab, use <span class="geshifilter"><code class="text geshifilter-text">:tabnew</code></span>, which optionally accepts a filename to open in the tab. You may then switch between tabs using the mouse, <span class="geshifilter"><code class="text geshifilter-text">:tabn</code></span> or <span class="geshifilter"><code class="text geshifilter-text">gt</code></span> to move to the next tab and <span class="geshifilter"><code class="text geshifilter-text">:tabp</code></span> or <span class="geshifilter"><code class="text geshifilter-text">gT</code></span> to move to the previous. Combine with terminal emulation, tabs really allow you to perform all of your coding and system operations from a single shell running vim.</p>
<h2 id="coding">What about syntax highlighting and indentation?</h2>
<p>There are several commands that you can place in your <a href="/csc201-laboratory-vim/exercise-8-vimrc-file" class="linodef linodef_node linodef_node_65" title="Node 65: Exercise 8: The .vimrc File">.vimrc</a> that will assist you as you develop software. The first, <span class="geshifilter"><code class="text geshifilter-text">:syntax on</code></span> tells vim to highlight the syntax of whatever filetype you are working with. If you are working with a file whose type is not properly recognized, you can force a particular syntax by using a command similar to <span class="geshifilter"><code class="text geshifilter-text">:set syntax=php</code></span>. Though there are lots of ways to add or alter the color schemes, I tend to find that the default syntax highlighting is just fine until I use a terminal with a dark background. Using <span class="geshifilter"><code class="text geshifilter-text">:set bg=dark</code></span> fixes this, and <span class="geshifilter"><code class="text geshifilter-text">:set bg=light</code></span> will return it. To add additional PHP-specific highlighting, you can add <span class="geshifilter"><code class="text geshifilter-text">let php_sql_query=1</code></span> to highlight SQL within strings and <span class="geshifilter"><code class="text geshifilter-text">let php_htmlInStrings=1</code></span> to highlight HTML within strings to your .vimrc. You'll probably also find the <span class="geshifilter"><code class="text geshifilter-text">:set number</code></span> option to be friendly, as it adds line numbers to the current buffer.</p>
<p>Indentation is controlled by a few commands, including <span class="geshifilter"><code class="text geshifilter-text">:set autoindent</code></span> which will indent your cursor for function definitions, for loops, etc. and automatically outdent (that's not a word) it when you reach the end of the block. <span class="geshifilter"><code class="text geshifilter-text">:set expandtab</code></span> makes the tab key insert a certain number of spaces rather than the tab character. This is a must if you ever plan to share your code as tabs will invariably appear at different lengths for different users. Two related options, <span class="geshifilter"><code class="text geshifilter-text">:set sts=2</code></span> (or <span class="geshifilter"><code class="text geshifilter-text">:set softtabstop=2</code></span>) and <span class="geshifilter"><code class="text geshifilter-text">:set sw=2</code></span> (or <span class="geshifilter"><code class="text geshifilter-text">:set shiftwidth=2</code></span>) declare how many spaces are in a tab/indentation. With both of these set to two, whenever I press the tab key or jump into a function, my cursor will be indented two spaces from where it was. The shiftwidth option is also used to determine how far to in-/outdent when using the <span class="geshifilter"><code class="text geshifilter-text">&gt;&gt;</code></span> or <span class="geshifilter"><code class="text geshifilter-text">&lt;&lt;</code></span> commands.</p>
<h2 id="filetype">My .module and .inc files don't appear as PHP?</h2>
<p>Vim uses a very simple file-extension=&gt;filetype scheme to figure out how to highlight syntax, perform auto-completion, etc. Drupal (and some other PHP applications) prefer to include their PHP as .module and .inc files. This is easy enough to fix by adding and <span class="geshifilter"><code class="text geshifilter-text">autocmd</code></span> which will explicitly set the filetype whenever you load one of these files. Explicitly, you should add<br />
<div class="geshifilter"><pre class="text geshifilter-text">autocmd BufRead,BufNewFile *.module set filetype=php
autocmd BufRead,BufNewFile *.install set filetype=php
autocmd BufRead,BufNewFile *.inc set filetype=php</pre></div> to your .vimrc so that it associates .module, .install, and .inc files as PHP files.</p>
<h2 id="folding">How do I get and use code folding?</h2>
<p>Vim has several configurations regarding code folding. If you are going to stick with PHP, the simplest folding mechanism is to add <span class="geshifilter"><code class="text geshifilter-text">let php_folding=1</code></span>, which folds class and function definitions such that<br />
<div class="geshifilter"><pre class="php geshifilter-php"><span class="kw2">function</span> example<span class="br0">&#40;</span><span class="re0">$param</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
<span class="co1">//  some functionality here</span>
<span class="br0">&#125;</span></pre></div> will be turned into a single, expandable line <span class="geshifilter"><code class="text geshifilter-text">function example($param)</code></span>. Getting a bit more sophisticated, Vim offers several options for a fold method (<span class="geshifilter"><code class="text geshifilter-text">:set foldmethod=option</code></span>). You can set this to <span class="geshifilter"><code class="text geshifilter-text">indent</code></span> to fold for lines with equal indentation, which would be optimal for a language like Python. You could set it to <span class="geshifilter"><code class="text geshifilter-text">syntax</code></span> which folds based on the file-type for languages that support this (I do not believe vim's PHP support does). I use <span class="geshifilter"><code class="text geshifilter-text">:set foldmethod=marker</code></span> to indicate that I want folds to be based on a particular marker (sequence of characters). I then use <span class="geshifilter"><code class="text geshifilter-text">:set foldmarker={,}</code></span>, which tells vim to create folds between every set of matching curly braces (which handles for loops, closures, etc. as well as class/function definitions). Finally, I use <span class="geshifilter"><code class="text geshifilter-text">:set foldlevel=1</code></span>, which makes it so that whenever I open a new php file, the outermost fold is open. This is great if you use a lot of PHP classes, because you'll want to see the class' methods but not their implementation. If you are just using Drupal (which avoids class definitions), you will probably want to leave this to its default (0).</p>
<p>Navigating folds is a snap. Use <span class="geshifilter"><code class="text geshifilter-text">zo</code></span> or the right arrow key to the fold which the cursor is on. Using <span class="geshifilter"><code class="text geshifilter-text">zO</code></span> will open not only the fold, but recursively open all folds within it. <span class="geshifilter"><code class="text geshifilter-text">zc</code></span> closes the current fold (from anywhere within it) while <span class="geshifilter"><code class="text geshifilter-text">zC</code></span> recursively closes to the highest level. <span class="geshifilter"><code class="text geshifilter-text">zR</code></span> opens all folds within the file. To manually create a fold, simple use <span class="geshifilter"><code class="text geshifilter-text">zf</code></span> + a movement. For example, you could create a fold of the next five lines with <span class="geshifilter"><code class="text geshifilter-text">zf5j</code></span> or the next paragraph with <span class="geshifilter"><code class="text geshifilter-text">zfap</code></span>. Note that when using a marker, vim will actually insert this marker into you code (thought it will attempt to comment the marker if possible), so be careful.</p>
<h2 id="completion">How do I enable/use code completion?</h2>
<p>When in insert (or replace) mode, you can activate "omnicompletion," which will do it's best to resolve the function, variable, etc. that you have started to type. For coders, you will generally use <span class="geshifilter"><code class="text geshifilter-text">&lt;C-x&gt;&lt;C-o&gt;</code></span> (that is, hold control and press x, then hold control and press o). This is easy to remember, just think about Vim giving you hugs and kisses (which it doesn't <em>generally</em> do. Omnicompletion will look through the dictionary of functions, variables, etc. and attempt to find the best for this situation, offering several as alternatives which can be selected via the arrow keys followed by <span class="geshifilter"><code class="text geshifilter-text">Enter</code></span> on the proper selection. When flipping through the various function endings, you'll notice that a new scratch window opens, showing each's signature. This window will stay open so that you may complete your call.</p>
<p>Before any of this can be useful, however, you must give Vim a proper dictionary of keywords, functions, etc. Vim provides a list of PHP-related terms which should be included when editing PHP files. To do this, include <span class="geshifilter"><code class="text geshifilter-text">au FileType php set omnifunc=phpcomplete#CompletePHP</code></span> in your .vimrc. This says that whenever the filetype gets set to php (usually when opening the file), include the standard library of PHP functions, keywords, etc. Omnicompletion will also pay attention to methods, variables, etc. found in the current file, and you can include your own library by include its tags (<a href="#tags">learn more</a>). With tags, the current file, and the php library at your finger tips, you'll find that you won't need to Google "php string methods" or "drupal hooks" ever again.</p>
<h2 id="tags">And how do I jump to the function code definition?</h2>
<p>Vim allows you to jump to the definitions of functions, classes, etc. so long as it is <em>aware</em> of their existence. Vim becomes aware of these definitions if they are coded in a standard format which is produced by the ctags (exuberant ctags) utility. Basically, this program will spit out a bunch of function, class, constant etc. definitions into a single file, which Vim can then load to figure out where to go when you want to learn more. For drupal/php work, I've written a script which will generate a tags file for the current code branch by running <span class="geshifilter"><code class="text geshifilter-text">$ ctags --langmap=php:.php.module.inc --languages=php -R .</code></span> which says, "include any file ending with .php, .module, or .inc as a php file," "create tags for php only," and "look at all of the files recursively within this directory." Running this command (it will take a moment) generates a file named "tags," which Vim will check for. Instead of requiring this file be in the current directory and named "tags," Vim allows you to define the tag file via the <span class="geshifilter"><code class="text geshifilter-text">:set tags=/path/to/file</code></span>.</p>
<p>Once the tag files are loaded, you will have the included methods, constants, etc. available for <a href="#completion">omnicompletion</a>, but you will also be able to jump the a function definition. To do this, move the cursor on top of the string in question and then run <span class="geshifilter"><code class="text geshifilter-text">&lt;C-w&gt;]</code></span>. This will cause the window to split, opening the file that defined the function (etc.) and jumping to the exact line of the definition. You may also type <span class="geshifilter"><code class="text geshifilter-text">&lt;C-]&gt;</code></span>, which will open the definition in the same viewport. This is particularly useful when debugging, as you can more or less follow the line of execution. You can then jump back (pop out of the definition) with the <span class="geshifilter"><code class="text geshifilter-text">&lt;C-t&gt;</code></span> command. Simple enough, right?</p>
<p>The <a  target='_blank' href="http://www.vim.org/scripts/script.php?script_id=273">Taglist</a> plugin uses a lot of the same mechanisms (using ctags as its backend), but figures the file classes, functions, etc. specifically for the files you are actively editing or have edited during this session. To turn this on, run <span class="geshifilter"><code class="text geshifilter-text">:TlistToggle</code></span>, which will open a vertical split with the taglist viewer on the left side. As you edit files, they will be added to the browser in that window, allowing you to quickly see the classes, etc. that you've come across. This plugin has a very large number of options, notably <span class="geshifilter"><code class="text geshifilter-text">TList_Process_File_Always</code></span>, which tells the plugin to gather tag information even when it is not visible. To set this, add <span class="geshifilter"><code class="text geshifilter-text">let Tlist_Process_File_Always = 1</code></span> to your .vimrc. As with many of the other plugins, you will probably want to add a hotkey to display this list by adding something like <span class="geshifilter"><code class="text geshifilter-text">noremap &lt;F6&gt; :TlistToggle&lt;CR&gt;</code></span>. The tag list has plenty of additional options (including the ability to recursively add directories and the ability to save/restore existing tag lists), so see the help documentation for more.</p>
<h2 id="lint">How can I check for syntax errors within my code?</h2>
<p>Checking for syntax errors, or "linting," prevents developers from wasting time testing a program/script that cannot work, and while clunky IDEs have included support for this for many languages, Vim has taken a more general approach. The basic idea is that you define the command line program which will lint over your source file using the <span class="geshifilter"><code class="text geshifilter-text">makeprg</code></span> option. For example, if using PHP, <span class="geshifilter"><code class="text geshifilter-text">:set makeprg=php\ -l\ %</code></span> will run the standard <span class="geshifilter"><code class="text geshifilter-text">php -l</code></span> command. This command will be ran whenever you run <span class="geshifilter"><code class="text geshifilter-text">:make</code></span>, which I strongly suggest mapping to some other key combination (e.g. <span class="geshifilter"><code class="text geshifilter-text">noremap &lt;F3&gt; :make&lt;CR&gt;</code></span> in your .vimrc). The output of this external program is then parsed for any errors using the <span class="geshifilter"><code class="text geshifilter-text">errorformat</code></span> option, which allows Vim to figure out which error, file, line number, column, etc. caused the error. If you set this up correctly, running <span class="geshifilter"><code class="text geshifilter-text">:make</code></span> will jump to the specific line which is causing a problem. For <span class="geshifilter"><code class="text geshifilter-text">php -l</code></span>, the error format should be something like <span class="geshifilter"><code class="text geshifilter-text">:set errorformat=%m\ in\ %f\ on\ line\ %l</code></span>. It'd be a good idea to set these based on the filetype with the <span class="geshifilter"><code class="text geshifilter-text">au FileType</code></span> command in your .vimrc; <span class="geshifilter"><code class="text geshifilter-text">au FileType php set makeprg=php\ -l\ %</code></span> would cover PHP.</p>
<h2 id="external">How do I use external commands as input or filters?</h2>
<p>There are three basic ways to run external programs from within Vim (four, if you count an <a href="#shell">embedded shell</a>). The first is to run an external program and review the output. You may want to quickly see which subversion branch the current file is on, for example, so you run <span class="geshifilter"><code class="text geshifilter-text">:!svn info</code></span>. As you can see, the syntax is pretty straight forward, just type a colon, an exclamation point ("bang") and then the name of the command as you would from the command line. As such, great way to quickly check what is eating up your server would be to run <span class="geshifilter"><code class="text geshifilter-text">:!top</code></span>. As we'll see in just a moment, this form more or less drops you into a single, external command.</p>
<p>Now, what if you want to take the output of an external command and do something useful with it, i.e. use it's output as input to your text editor? Simple add an 'r' before the bang and that program's output will be placed into the current buffer. For example, if I'd like to find all source files that use a particular function, I can use <span class="geshifilter"><code class="text geshifilter-text">:r!grep &quot;myfunc&quot; -R .</code></span>; this becomes exceedingly useful when combined with the <span class="geshifilter"><code class="text geshifilter-text">&lt;C-w&gt;f</code></span> command, which will treat the string currently under the cursor as a file and try to open it. I use this all the time to grab a big list of files which contain a given method call that I'd like to refactor. I take that list of files, weed out any that don't apply (svn copies, similar function names, etc.) and then <span class="geshifilter"><code class="text geshifilter-text">?&lt;C-w&gt;f</code></span> each line to edit the corresponding function call.</p>
<p>You can also use an external program as a filter for the text within your current buffer. This means that you will send selected text to some program and Vim will replace the text with the program's output. To do this, select the text in visual mode and type <span class="geshifilter"><code class="text geshifilter-text">!command-name</code></span>. Say you need to quickly modify a chunk of code to wrap at 80 characters; highlight the code, then <span class="geshifilter"><code class="text geshifilter-text">!fmt</code></span> and everything will be snazzy. What if you have a CSV file which you'd like to sort without importing it into Open Office? Open it in Vim, highlight all (<span class="geshifilter"><code class="text geshifilter-text">ggVG</code></span>) and then <span class="geshifilter"><code class="text geshifilter-text">!sort</code></span>. In both cases, you send the text in the filter to the external programs for processing.</p>
<h2 id="shell">What do I need to run a shell within vim?</h2>
<p>There are several plugins that allow you to run a shell within vim, but I've found <a  target='_blank' href="http://www.vim.org/scripts/script.php?script_id=2771">Conque Shell</a> to be the best. You will need Vim compiled with Python (which is probably the case unless you compiled it yourself). The idea behind running a Conque Shell is that you split your window (or re-use an existing viewport) to run a particular shell, whether that be bash (an obvious choice), mysql/psql, an interpreter, or any other command-line program. To open an instance of top, simply type <span class="geshifilter"><code class="text geshifilter-text">:ConqueTerm top</code></span>. If you started to type that and then tried tab-completion, good call! To make it even faster, we can create a simple key binding. I use F5, so my .vimrc includes <span class="geshifilter"><code class="text geshifilter-text">noremap &lt;F5&gt; :ConqueTermSplit bash&lt;CR&gt;</code></span>. While in the shell, insert/append mode will type to the shell's program. You can, however, press <span class="geshifilter"><code class="text geshifilter-text">ESC</code></span> to enter command mode and move around the shell's output as if it were a text document. Cool stuff!</p>
<h2 id="nerdtree">Is there some sort of file browser?</h2>
<p>As with the <a href="#shell">embedded shell</a>, there are multiple file browser plugins for Vim, but the most popular is <a  target='_blank' href="http://www.vim.org/scripts/script.php?script_id=1658">NERD tree</a>. This plugin will create a vertical split when the <span class="geshifilter"><code class="text geshifilter-text">:NERDTree</code></span> command is invoked, displaying a list of files and folders in the current directory. If you double-click (or press <span class="geshifilter"><code class="text geshifilter-text">Enter</code></span>) on one of these files, it will open in the most recently accesses viewport. Doing the same on a folder will expand that folder so that you may select its subdirectories or files. The interface is remarkably intuitive (especially for Vim) to the point where point-and-click will accomplish 99% of what you need. There is a lot of advanced functionality, including the ability to add bookmarks and a plethora of key-bindings (<span class="geshifilter"><code class="text geshifilter-text">F</code></span> toggles showing hidden files, <span class="geshifilter"><code class="text geshifilter-text">A</code></span> toggles a maximized window, etc.), but I will leave you to look at the help pages to discover them all. As with the embedded shell, you will probably want to tie this to a specific hotkey, adding something like <span class="geshifilter"><code class="text geshifilter-text">noremap &lt;F4&gt; :NERDTree&lt;CR&gt;</code></span> to your .vimrc.</p>
